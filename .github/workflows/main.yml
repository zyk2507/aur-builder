name: Build AUR (multi pkgs groups), Archive & Release

on:
  push:
    branches: [ main, master ]
  workflow_dispatch:
  schedule:
    # 每天 18:30 UTC 触发（= 次日 02:30 Asia/Singapore）
    - cron: '30 18 * * *'

permissions:
  contents: write  # 创建/更新 Release 与上传资产

jobs:
  build-aur:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Ensure upload folder exists
        run: |
          mkdir -p "${{ github.workspace }}/upload"

      - name: Discover package groups (subfolders with pkgs.txt)
        id: discover
        shell: bash
        run: |
          set -euo pipefail
          ROOT="${{ github.workspace }}/packages"
          if [[ ! -d "$ROOT" ]]; then
            echo "ERROR: packages/ 不存在"
            exit 1
          fi

          # 找出 packages/ 下含 pkgs.txt 的子目录（一级或更深层级都可）
          mapfile -t groups < <(find "$ROOT" -type f -name 'pkgs.txt' -printf '%h\n' | sort -u)
          if [[ "${#groups[@]}" -eq 0 ]]; then
            echo "ERROR: 未在 packages/ 下找到任何包含 pkgs.txt 的子目录"
            exit 1
          fi

          printf '发现以下包组目录：\n'
          printf ' - %s\n' "${groups[@]}"

          # 以 :: 分隔拼接，传给后续步骤
          echo "GROUPS=$(printf '%s::' "${groups[@]}")" >> "$GITHUB_ENV"

      - name: Install 7-Zip
        run: |
          sudo apt-get update
          sudo apt-get install -y p7zip-full

      - name: Loop build per group (rebuild image each time)
        shell: bash
        run: |
          set -euo pipefail
          IFS='::' read -ra GROUPS <<< "${GROUPS:-}"

          # 逐个子目录处理：删除上个镜像 -> 重新构建 -> 运行容器（仅挂载该子目录）
          for g in "${GROUPS[@]}"; do
            [[ -z "$g" ]] && continue
            echo "=============================="
            echo "==> 处理包组目录: $g"
            echo "=============================="

            # 删除上一个镜像（若存在）
            docker rmi -f aur-builder:latest || true

            # 重新构建镜像（可用 --no-cache 保证完全干净）
            docker build --no-cache -t aur-builder:latest .

            # 运行容器：仅挂载当前包组目录为 /opt/packages
            docker run --rm \
              -v "${{ github.workspace }}/upload:/opt/upload" \
              -v "$g:/opt/packages" \
              aur-builder:latest

          done

      - name: Compress upload/ (single first; only split if >1.9GB)
        shell: bash
        working-directory: ${{ github.workspace }}
        run: |
          set -euo pipefail

          if [[ ! -d "upload" ]]; then
            echo "ERROR: upload/ not found"
            exit 1
          fi

          # 先生成单一 7z 包；打整个目录，避免空目录异常
          7z a -mx=9 -mmt=on "upload.7z" "./upload" >/dev/null

          BYTES=$(stat -c%s "upload.7z")
          echo "Packed size (bytes): ${BYTES}"

          # 阈值 1.9GB
          THRESHOLD=$((1900 * 1024 * 1024))

          if [ "${BYTES}" -gt "${THRESHOLD}" ]; then
            echo "is_split=true" >> "$GITHUB_ENV"
            # 用原生 7z 多卷重新打包（每卷 1900MB）
            rm -f upload.7z
            7z a -mx=9 -mmt=on -v1900m "upload.7z" "./upload" >/dev/null
            # 产物示例：upload.7z.001, upload.7z.002, ...
            echo "RELEASE_FILES=upload.7z.*" >> "$GITHUB_ENV"
          else
            echo "is_split=false" >> "$GITHUB_ENV"
            echo "RELEASE_FILES=upload.7z" >> "$GITHUB_ENV"
          fi

      - name: Prepare release tag (Asia/Singapore -> mmddyyyy-hh-mm-ss)
        id: prep_tag
        shell: bash
        run: |
          TZ=Asia/Singapore
          VERSION=$(TZ=$TZ date '+%m%d%Y-%H-%M-%S')
          echo "RELEASE_TAG=$VERSION" >> "$GITHUB_ENV"
          echo "Release tag: $VERSION"

      - name: Create/Update Release & Upload assets
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ env.RELEASE_TAG }}
          name: ${{ env.RELEASE_TAG }}
          files: ${{ env.RELEASE_FILES }}
          draft: false
          prerelease: false
          make_latest: true
          fail_on_unmatched_files: true

      # 可选：把同样的输出也保存成工作流 Artifact
      - name: Upload artifact (single)
        if: env.is_split == 'false'
        uses: actions/upload-artifact@v4
        with:
          name: upload-archive
          path: upload.7z
          compression-level: 0

      - name: Upload artifact (multi-volume)
        if: env.is_split == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: upload-archive-split
          path: upload.7z.*
          compression-level: 0
